# 패리티 비트란?

- 데이터를 전송, 저장할 때 비트가 바뀌는 오류를 감지 하기 위해 붙이는 **_검사용 비트_**
- 전체 데이터의 비트에서 '1'의 갯수를 기준으로 잡음

1. 짝수 패리티 (1의 개수를 짝수로 맞춤)
2. 홀수 패리티 (1의 개수를 홀수로 맞춤)  
   ex) data : 1011001(1이 4개 ->짝수 )

- 짝수 패리티 비트 -> 0을 추가 (1이 짝수개 )
- 홀수 패리티 비트 -> 1을 추가 (1이 홀수개 )
  패리티 비트는 맨 앞이나 맨 뒤에 붙인다.
  상관은 없지만, 검사를 하려면 어디에 있는지 서로가 알고 있어야 한다.
  우리가 정한 패리티 방식에 따라서 오류를 검수한다
  짝수형을 선택한 경우
  1의 갯수가 짝수로 유지 되어야 하지만
  데이터 전송중에 비트가 변경되어 1의 갯수가 짝수가 아닌경우 = 데이터에 오류가 발생했다는 것

**_한계점_**
한개의 비트만 감지 가능하다
두개 이상의 비트가 바뀌면 홀수 짝수 의미가 없기 때문

# 해밍 코드란?

- 데이터에 여러 개의 패리티 비트를 삽입해서, 오류가 발생한 위치, 오류 수정까지 가능하게 하는 코드
- 각각 2의 n승 자리에 패리티 비트를 끼워넣는다.
  ex) 실제 전송 데이터 = **_1101_** [p가 패리티 비트 ]
- P1 P2 1 P4 1 0 1
- 이때 짝수 패리티 인지 홀수 패리티 인지 정하여 넣는다.

  각각의 패리티 비트는 (P1, P2 , P4 , P8 , ....) 검사하는 데이터 자리가 정해져 있다.
  Pn은 자기 부터 시작해서 n 개 검사하고 n 개 건너뛰고 이런식이다
  P1 = 1 3 5 7 검수
  P2 = 2 3 ~ ~ 6 7 검수
  P4 = 4 5 6 7 ~ ~ ~ ~ 검수
  이런식으로 각자 자기 자리를 검수하여 패리티 비트를 이용해서 요류를 검출한다

### 해밍 코드를 이용한 오류 수정 법

그래서 나온 해밍 코드 = 1 0 1 0 1 0 1 (짝수 패리티)
_여기서 6번쨰 비트가 0->1로 바뀌었다는 오류를 가정_
각각의 패리티 비트를 검수해서 오류가 있으면 1 , 오류가 없으면 0
패리티 비트를 마지막 순서부터 나열함
ex) P4 , P2 , P1 = 1 1 0
이렇게 해서 나온 비트를 십진법으로 전환하면 어디서 오류가 난지 알 수 있음
110을 십진수로 전환하면 '6'
이렇게 해서 오류를 찾고 수정까지 할 수 있는 해밍 코드이다

**_한계점_**
기본적으로 패리티 비트를 이용한 코드이므로 다중 비트 오류에는 취약함
